---
layout: post
title: "탐욕 알고리즘이란?"
subtitle: "무언가를 욕심낸다는건가?"
banner:
  image: https://github.com/user-attachments/assets/dc12349a-6535-469e-a2a5-b035092ec02f
author: UncleCoder
tags:
    - algorithm-study
    - greedy-algorithm
categories: algorithm-study
date: "2024-10-16 20:30:00 +0900"              
last_modified_at: "2024-10-12 20:30:00 +0900"   
---

## 1. 개요
그리디 알고리즘(greedy algorithm) 이라고도 하며, 지금 이 순간 당장 선택할 수 있는 최적의 답을 찾기 위한 알고리즘이다.
즉, 주어진 문제에 대한 근본적인 최적의 해를 찾는 게 아닌, 그 근사치를 찾기 위한 알고리즘이라고 할 수 있다.

## 2. 특징
그리디 알고리즘은, 아래와 같은 특성을 가진 문제를 해결할 때 강점이 있다.
### 2.1. 탐욕스러운 선택 조건 (Greedy Choice Property)
> 앞에서 선택한 것이 이후의 선택에 영향을 주지 말아야 한다.

알고리즘 특성상, 앞에서 선택한 것이 이후의 선택에 영향을 줘야하는 경우가 있는데, 그런 경우에는 적합하지 않다는 뜻이다. (대표적인 예: 외판원 문제)

### 2.2. 최적 부분 구조 조건 (Optimal Substructure)
> 주어진 문제에 대한 최적해는 부분 문제에 대한 최적해로 구성된다.

`부분 문제에 대한 최적해로 구성된다.` 라는 어휘 때문에 조금 어렵게 느껴졌는데, 여러 문서를 찾아 보니 별거 없더라.

1. 주어진 문제를 적절한 범위로 쪼갠다. (주어진 문제를 적절하게 쪼갠 것 = 부분 문제)
2. 부분 문제별로, 최적의 해를 구한다. (개별 부분 문제에 대한 최적해를 구한다.)
3. 쪼갠 범위별 최적 답안을 모아, 하나의 답안으로 조합한다. (여러개로 나누어진 부분 문제에 대한 최적해를 모아, 하나로 `구성` 한다.)
4. 짜잔! 주어진 문제에 대한 최적 해 완성!
  - 주어진 문제 : 부분 문제 여러개로 `구성` 된 문제.
  - 주어진 문제의 최적 해: 부분 문제의 최적해 여러개 개를 하나로 모은(=구성한) 것.

결론적으로, 내가 `구성하다` 라는 단어와 친하지 않아 발생한 참사였다. 본의아니게 장황한 글이 되었지만, 나의 부족한 어휘력을 반성하는 계기로 삼기 위해 기록코자 한다.


## 3. 예시
### 3.1 탐욕 알고리즘으로 최적 해를 도출하는 데 성공한 경우
서울에서 대전과 동대구를 거쳐 부산까지 가는, 최대한 빨리 갈 수 있는 경로를 찾는다고 가정한다.

<div class="mermaid"> 
flowchart LR;
A(서울);
B(대전);
C(동대구);
D(부산);


A -->|✅ **KTX: 59분**| B;
A -->|새마을: 1시간 45분| B;
A -->|무궁화: 2시간 5분| B;
B -->|✅ **KTX: 49분**| C;
B -->|새마을: 1시간 40분| C;
B -->|새마을: 1시간 58분| C;
C -->|✅ **KTX: 46분**| D;
C -->|새마을: 1시간 14분| D;
C -->|무궁화호: 1시간 29분| D;
</div>


`너무 뻔한 걸 예시랍치고 가져와서 민망하지만`, 그리디 알고리즘이 효과를 발휘할 수 있는 예시 중 하나라고 볼 수 있다.

### 3.2 탐욕 알고리즘으로 최적 해를 도출하는데 실패했을 경우 
아래와 같은 트리를 탐색하며 선택해나간 값의 합계가 가장 큰 값을 구해야 한다고 가정해보자.
<div class="mermaid"> 
flowchart TD;
    start("START") --- r0d("6") & r1d("5");
    r0d --- r2d("7") & r3d("10");
    r1d --- r4d("8") & r5d("4");
    r2d --- r6d("1") & r7d("1");
    r3d --- r8d("4") & r9d("2");
    r4d --- r10d("3") & r11d("8");
    r5d --- r12d("4") & r13d("25");
    style r0d stroke:#D50000,fill:#D50000,color:#FFFFFF;
    style r1d stroke:#2962FF,fill:#2962FF,color:#FFFFFF;
    style r3d stroke:#D50000,fill:#D50000,color:#FFFFFF;
    style r5d stroke:#2962FF,fill:#2962FF,color:#FFFFFF;
    style r8d stroke:#D50000,fill:#D50000,color:#FFFFFF;
    style r13d stroke:#2962FF,fill:#2962FF,color:#FFFFFF;
    linkStyle 3 stroke:#D50000,fill:none;
    linkStyle 5 stroke:#2962FF,fill:none;
    linkStyle 8 stroke:#D50000,fill:none;
    linkStyle 13 stroke:#2962FF,fill:none;
</div>

<span style="color:blue">**가장 좋은 결과: 5 → 4 → 25 (합계: 34)**</span>

<span style="color:red">**탐욕 알고리즘이 선택한 결과: 6 → 10 → 4 (합계: 20)** </span>

탐욕 알고리즘이 선택한 결과는 가장 이상적인 결과와는 조금 다른 결과가 나왔다.
주어진 문제에서 가장 좋은 결과를 도출해 내려면, 저 트리를 모두 다 탐색해보는 게 조금 더 올바른 방법이었을 것이다.

하지만 그러기에는 주어진 시간과 자원이 충분치 못한 경우가 많기에, 최적 값 도출 정확도는 다소 희생하더라도, 빠른 시간 내에 `그럴싸한` 근사값을 추출하는 데는 좋은 방법이라 생각한다.

**덧:** 문제로 주어진 트리를 **정렬** 한 후에 탐욕 알고리즘을 실행시켰다면, 결과는 달라졌을 수도 있겠다는 생각이 들었다.

### 4. 관련 알고리즘
- 프림(Prim) 알고리즘
- 크루스칼 (Kruskal) 알고리즘
- 다익스트라(Dijkstra) 알고리즘
- 허프만 코드 (huffman code) 알고리즘
